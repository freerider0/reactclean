import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/polygon-offset/src/edge.js
var require_edge = __commonJS({
  "node_modules/polygon-offset/src/edge.js"(exports, module) {
    function Edge(current, next) {
      this.current = current;
      this.next = next;
      this._inNormal = this.inwardsNormal();
      this._outNormal = this.outwardsNormal();
    }
    Edge.prototype.outwardsNormal = function() {
      var inwards = this.inwardsNormal();
      return [
        -inwards[0],
        -inwards[1]
      ];
    };
    Edge.prototype.inwardsNormal = function() {
      var dx = this.next[0] - this.current[0], dy = this.next[1] - this.current[1], edgeLength = Math.sqrt(dx * dx + dy * dy);
      if (edgeLength === 0) throw new Error("Vertices overlap");
      return [
        -dy / edgeLength,
        dx / edgeLength
      ];
    };
    Edge.prototype.offset = function(dx, dy) {
      return Edge.offsetEdge(this.current, this.next, dx, dy);
    };
    Edge.prototype.inverseOffset = function(dx, dy) {
      return Edge.offsetEdge(this.next, this.current, dx, dy);
    };
    Edge.offsetEdge = function(current, next, dx, dy) {
      return new Edge([
        current[0] + dx,
        current[1] + dy
      ], [
        next[0] + dx,
        next[1] + dy
      ]);
    };
    Edge.prototype.inverse = function() {
      return new Edge(this.next, this.current);
    };
    module.exports = Edge;
  }
});

// node_modules/martinez-polygon-clipping/src/edge_type.js
var require_edge_type = __commonJS({
  "node_modules/martinez-polygon-clipping/src/edge_type.js"(exports, module) {
    module.exports = {
      NORMAL: 0,
      NON_CONTRIBUTING: 1,
      SAME_TRANSITION: 2,
      DIFFERENT_TRANSITION: 3
    };
  }
});

// node_modules/tinyqueue/index.js
var require_tinyqueue = __commonJS({
  "node_modules/tinyqueue/index.js"(exports, module) {
    "use strict";
    module.exports = TinyQueue;
    module.exports.default = TinyQueue;
    function TinyQueue(data, compare) {
      if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
      this.data = data || [];
      this.length = this.data.length;
      this.compare = compare || defaultCompare;
      if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
      }
    }
    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    TinyQueue.prototype = {
      push: function(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
      },
      pop: function() {
        if (this.length === 0) return void 0;
        var top = this.data[0];
        this.length--;
        if (this.length > 0) {
          this.data[0] = this.data[this.length];
          this._down(0);
        }
        this.data.pop();
        return top;
      },
      peek: function() {
        return this.data[0];
      },
      _up: function(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];
        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }
        data[pos] = item;
      },
      _down: function(pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];
        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var right = left + 1;
          var best = data[left];
          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }
          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }
        data[pos] = item;
      }
    };
  }
});

// node_modules/bintrees/lib/treebase.js
var require_treebase = __commonJS({
  "node_modules/bintrees/lib/treebase.js"(exports, module) {
    function TreeBase() {
    }
    TreeBase.prototype.clear = function() {
      this._root = null;
      this.size = 0;
    };
    TreeBase.prototype.find = function(data) {
      var res = this._root;
      while (res !== null) {
        var c = this._comparator(data, res.data);
        if (c === 0) {
          return res.data;
        } else {
          res = res.get_child(c > 0);
        }
      }
      return null;
    };
    TreeBase.prototype.findIter = function(data) {
      var res = this._root;
      var iter = this.iterator();
      while (res !== null) {
        var c = this._comparator(data, res.data);
        if (c === 0) {
          iter._cursor = res;
          return iter;
        } else {
          iter._ancestors.push(res);
          res = res.get_child(c > 0);
        }
      }
      return null;
    };
    TreeBase.prototype.lowerBound = function(item) {
      var cur = this._root;
      var iter = this.iterator();
      var cmp = this._comparator;
      while (cur !== null) {
        var c = cmp(item, cur.data);
        if (c === 0) {
          iter._cursor = cur;
          return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
      }
      for (var i = iter._ancestors.length - 1; i >= 0; --i) {
        cur = iter._ancestors[i];
        if (cmp(item, cur.data) < 0) {
          iter._cursor = cur;
          iter._ancestors.length = i;
          return iter;
        }
      }
      iter._ancestors.length = 0;
      return iter;
    };
    TreeBase.prototype.upperBound = function(item) {
      var iter = this.lowerBound(item);
      var cmp = this._comparator;
      while (iter.data() !== null && cmp(iter.data(), item) === 0) {
        iter.next();
      }
      return iter;
    };
    TreeBase.prototype.min = function() {
      var res = this._root;
      if (res === null) {
        return null;
      }
      while (res.left !== null) {
        res = res.left;
      }
      return res.data;
    };
    TreeBase.prototype.max = function() {
      var res = this._root;
      if (res === null) {
        return null;
      }
      while (res.right !== null) {
        res = res.right;
      }
      return res.data;
    };
    TreeBase.prototype.iterator = function() {
      return new Iterator(this);
    };
    TreeBase.prototype.each = function(cb) {
      var it = this.iterator(), data;
      while ((data = it.next()) !== null) {
        if (cb(data) === false) {
          return;
        }
      }
    };
    TreeBase.prototype.reach = function(cb) {
      var it = this.iterator(), data;
      while ((data = it.prev()) !== null) {
        if (cb(data) === false) {
          return;
        }
      }
    };
    function Iterator(tree) {
      this._tree = tree;
      this._ancestors = [];
      this._cursor = null;
    }
    Iterator.prototype.data = function() {
      return this._cursor !== null ? this._cursor.data : null;
    };
    Iterator.prototype.next = function() {
      if (this._cursor === null) {
        var root = this._tree._root;
        if (root !== null) {
          this._minNode(root);
        }
      } else {
        if (this._cursor.right === null) {
          var save;
          do {
            save = this._cursor;
            if (this._ancestors.length) {
              this._cursor = this._ancestors.pop();
            } else {
              this._cursor = null;
              break;
            }
          } while (this._cursor.right === save);
        } else {
          this._ancestors.push(this._cursor);
          this._minNode(this._cursor.right);
        }
      }
      return this._cursor !== null ? this._cursor.data : null;
    };
    Iterator.prototype.prev = function() {
      if (this._cursor === null) {
        var root = this._tree._root;
        if (root !== null) {
          this._maxNode(root);
        }
      } else {
        if (this._cursor.left === null) {
          var save;
          do {
            save = this._cursor;
            if (this._ancestors.length) {
              this._cursor = this._ancestors.pop();
            } else {
              this._cursor = null;
              break;
            }
          } while (this._cursor.left === save);
        } else {
          this._ancestors.push(this._cursor);
          this._maxNode(this._cursor.left);
        }
      }
      return this._cursor !== null ? this._cursor.data : null;
    };
    Iterator.prototype._minNode = function(start) {
      while (start.left !== null) {
        this._ancestors.push(start);
        start = start.left;
      }
      this._cursor = start;
    };
    Iterator.prototype._maxNode = function(start) {
      while (start.right !== null) {
        this._ancestors.push(start);
        start = start.right;
      }
      this._cursor = start;
    };
    module.exports = TreeBase;
  }
});

// node_modules/bintrees/lib/rbtree.js
var require_rbtree = __commonJS({
  "node_modules/bintrees/lib/rbtree.js"(exports, module) {
    var TreeBase = require_treebase();
    function Node(data) {
      this.data = data;
      this.left = null;
      this.right = null;
      this.red = true;
    }
    Node.prototype.get_child = function(dir) {
      return dir ? this.right : this.left;
    };
    Node.prototype.set_child = function(dir, val) {
      if (dir) {
        this.right = val;
      } else {
        this.left = val;
      }
    };
    function RBTree(comparator) {
      this._root = null;
      this._comparator = comparator;
      this.size = 0;
    }
    RBTree.prototype = new TreeBase();
    RBTree.prototype.insert = function(data) {
      var ret2 = false;
      if (this._root === null) {
        this._root = new Node(data);
        ret2 = true;
        this.size++;
      } else {
        var head = new Node(void 0);
        var dir = 0;
        var last = 0;
        var gp = null;
        var ggp = head;
        var p = null;
        var node = this._root;
        ggp.right = this._root;
        while (true) {
          if (node === null) {
            node = new Node(data);
            p.set_child(dir, node);
            ret2 = true;
            this.size++;
          } else if (is_red(node.left) && is_red(node.right)) {
            node.red = true;
            node.left.red = false;
            node.right.red = false;
          }
          if (is_red(node) && is_red(p)) {
            var dir2 = ggp.right === gp;
            if (node === p.get_child(last)) {
              ggp.set_child(dir2, single_rotate(gp, !last));
            } else {
              ggp.set_child(dir2, double_rotate(gp, !last));
            }
          }
          var cmp = this._comparator(node.data, data);
          if (cmp === 0) {
            break;
          }
          last = dir;
          dir = cmp < 0;
          if (gp !== null) {
            ggp = gp;
          }
          gp = p;
          p = node;
          node = node.get_child(dir);
        }
        this._root = head.right;
      }
      this._root.red = false;
      return ret2;
    };
    RBTree.prototype.remove = function(data) {
      if (this._root === null) {
        return false;
      }
      var head = new Node(void 0);
      var node = head;
      node.right = this._root;
      var p = null;
      var gp = null;
      var found = null;
      var dir = 1;
      while (node.get_child(dir) !== null) {
        var last = dir;
        gp = p;
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;
        if (cmp === 0) {
          found = node;
        }
        if (!is_red(node) && !is_red(node.get_child(dir))) {
          if (is_red(node.get_child(!dir))) {
            var sr = single_rotate(node, dir);
            p.set_child(last, sr);
            p = sr;
          } else if (!is_red(node.get_child(!dir))) {
            var sibling = p.get_child(!last);
            if (sibling !== null) {
              if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                p.red = false;
                sibling.red = true;
                node.red = true;
              } else {
                var dir2 = gp.right === p;
                if (is_red(sibling.get_child(last))) {
                  gp.set_child(dir2, double_rotate(p, last));
                } else if (is_red(sibling.get_child(!last))) {
                  gp.set_child(dir2, single_rotate(p, last));
                }
                var gpc = gp.get_child(dir2);
                gpc.red = true;
                node.red = true;
                gpc.left.red = false;
                gpc.right.red = false;
              }
            }
          }
        }
      }
      if (found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
      }
      this._root = head.right;
      if (this._root !== null) {
        this._root.red = false;
      }
      return found !== null;
    };
    function is_red(node) {
      return node !== null && node.red;
    }
    function single_rotate(root, dir) {
      var save = root.get_child(!dir);
      root.set_child(!dir, save.get_child(dir));
      save.set_child(dir, root);
      root.red = true;
      save.red = false;
      return save;
    }
    function double_rotate(root, dir) {
      root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
      return single_rotate(root, dir);
    }
    module.exports = RBTree;
  }
});

// node_modules/bintrees/lib/bintree.js
var require_bintree = __commonJS({
  "node_modules/bintrees/lib/bintree.js"(exports, module) {
    var TreeBase = require_treebase();
    function Node(data) {
      this.data = data;
      this.left = null;
      this.right = null;
    }
    Node.prototype.get_child = function(dir) {
      return dir ? this.right : this.left;
    };
    Node.prototype.set_child = function(dir, val) {
      if (dir) {
        this.right = val;
      } else {
        this.left = val;
      }
    };
    function BinTree(comparator) {
      this._root = null;
      this._comparator = comparator;
      this.size = 0;
    }
    BinTree.prototype = new TreeBase();
    BinTree.prototype.insert = function(data) {
      if (this._root === null) {
        this._root = new Node(data);
        this.size++;
        return true;
      }
      var dir = 0;
      var p = null;
      var node = this._root;
      while (true) {
        if (node === null) {
          node = new Node(data);
          p.set_child(dir, node);
          ret = true;
          this.size++;
          return true;
        }
        if (this._comparator(node.data, data) === 0) {
          return false;
        }
        dir = this._comparator(node.data, data) < 0;
        p = node;
        node = node.get_child(dir);
      }
    };
    BinTree.prototype.remove = function(data) {
      if (this._root === null) {
        return false;
      }
      var head = new Node(void 0);
      var node = head;
      node.right = this._root;
      var p = null;
      var found = null;
      var dir = 1;
      while (node.get_child(dir) !== null) {
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;
        if (cmp === 0) {
          found = node;
        }
      }
      if (found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this._root = head.right;
        this.size--;
        return true;
      } else {
        return false;
      }
    };
    module.exports = BinTree;
  }
});

// node_modules/bintrees/index.js
var require_bintrees = __commonJS({
  "node_modules/bintrees/index.js"(exports, module) {
    module.exports = {
      RBTree: require_rbtree(),
      BinTree: require_bintree()
    };
  }
});

// node_modules/martinez-polygon-clipping/src/signed_area.js
var require_signed_area = __commonJS({
  "node_modules/martinez-polygon-clipping/src/signed_area.js"(exports, module) {
    module.exports = function signedArea(p0, p1, p2) {
      return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);
    };
  }
});

// node_modules/martinez-polygon-clipping/src/sweep_event.js
var require_sweep_event = __commonJS({
  "node_modules/martinez-polygon-clipping/src/sweep_event.js"(exports, module) {
    var signedArea = require_signed_area();
    var EdgeType = require_edge_type();
    function SweepEvent(point, left, otherEvent, isSubject, edgeType) {
      this.left = left;
      this.point = point;
      this.otherEvent = otherEvent;
      this.isSubject = isSubject;
      this.type = edgeType || EdgeType.NORMAL;
      this.inOut = false;
      this.otherInOut = false;
      this.prevInResult = null;
      this.inResult = false;
      this.resultInOut = false;
    }
    SweepEvent.prototype = {
      /**
       * @param  {Array.<Number>}  p
       * @return {Boolean}
       */
      isBelow: function(p) {
        return this.left ? signedArea(this.point, this.otherEvent.point, p) > 0 : signedArea(this.otherEvent.point, this.point, p) > 0;
      },
      /**
       * @param  {Array.<Number>}  p
       * @return {Boolean}
       */
      isAbove: function(p) {
        return !this.isBelow(p);
      },
      /**
       * @return {Boolean}
       */
      isVertical: function() {
        return this.point[0] === this.otherEvent.point[0];
      }
    };
    module.exports = SweepEvent;
  }
});

// node_modules/martinez-polygon-clipping/src/compare_events.js
var require_compare_events = __commonJS({
  "node_modules/martinez-polygon-clipping/src/compare_events.js"(exports, module) {
    var signedArea = require_signed_area();
    module.exports = function sweepEventsComp(e1, e2) {
      var p1 = e1.point;
      var p2 = e2.point;
      if (p1[0] > p2[0]) return 1;
      if (p1[0] < p2[0]) return -1;
      if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;
      return specialCases(e1, e2, p1, p2);
    };
    function specialCases(e1, e2, p1, p2) {
      if (e1.left !== e2.left)
        return e1.left ? 1 : -1;
      if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
        return !e1.isBelow(e2.otherEvent.point) ? 1 : -1;
      }
      return !e1.isSubject && e2.isSubject ? 1 : -1;
    }
  }
});

// node_modules/martinez-polygon-clipping/src/equals.js
var require_equals = __commonJS({
  "node_modules/martinez-polygon-clipping/src/equals.js"(exports, module) {
    module.exports = function equals(p1, p2) {
      return p1[0] === p2[0] && p1[1] === p2[1];
    };
  }
});

// node_modules/martinez-polygon-clipping/src/compare_segments.js
var require_compare_segments = __commonJS({
  "node_modules/martinez-polygon-clipping/src/compare_segments.js"(exports, module) {
    var signedArea = require_signed_area();
    var compareEvents = require_compare_events();
    var equals = require_equals();
    module.exports = function compareSegments(le1, le2) {
      if (le1 === le2) return 0;
      if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 || signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {
        if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;
        if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;
        if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;
        return le1.isBelow(le2.point) ? -1 : 1;
      }
      if (le1.isSubject === le2.isSubject) {
        if (equals(le1.point, le2.point)) {
          if (equals(le1.otherEvent.point, le2.otherEvent.point)) {
            return 0;
          } else {
            return le1.contourId > le2.contourId ? 1 : -1;
          }
        }
      } else {
        return le1.isSubject ? -1 : 1;
      }
      return compareEvents(le1, le2) === 1 ? 1 : -1;
    };
  }
});

// node_modules/martinez-polygon-clipping/src/segment_intersection.js
var require_segment_intersection = __commonJS({
  "node_modules/martinez-polygon-clipping/src/segment_intersection.js"(exports, module) {
    var EPSILON = 1e-9;
    function krossProduct(a, b) {
      return a[0] * b[1] - a[1] * b[0];
    }
    function dotProduct(a, b) {
      return a[0] * b[0] + a[1] * b[1];
    }
    module.exports = function(a1, a2, b1, b2, noEndpointTouch) {
      var va = [a2[0] - a1[0], a2[1] - a1[1]];
      var vb = [b2[0] - b1[0], b2[1] - b1[1]];
      function toPoint(p, s2, d) {
        return [
          p[0] + s2 * d[0],
          p[1] + s2 * d[1]
        ];
      }
      var e = [b1[0] - a1[0], b1[1] - a1[1]];
      var kross = krossProduct(va, vb);
      var sqrKross = kross * kross;
      var sqrLenA = dotProduct(va, va);
      var sqrLenB = dotProduct(vb, vb);
      if (sqrKross > EPSILON * sqrLenA * sqrLenB) {
        var s = krossProduct(e, vb) / kross;
        if (s < 0 || s > 1) {
          return null;
        }
        var t = krossProduct(e, va) / kross;
        if (t < 0 || t > 1) {
          return null;
        }
        return noEndpointTouch ? null : [toPoint(a1, s, va)];
      }
      var sqrLenE = dotProduct(e, e);
      kross = krossProduct(e, va);
      sqrKross = kross * kross;
      if (sqrKross > EPSILON * sqrLenA * sqrLenE) {
        return null;
      }
      var sa = dotProduct(va, e) / sqrLenA;
      var sb = sa + dotProduct(va, vb) / sqrLenA;
      var smin = Math.min(sa, sb);
      var smax = Math.max(sa, sb);
      if (smin <= 1 && smax >= 0) {
        if (smin === 1) {
          return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
        }
        if (smax === 0) {
          return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
        }
        if (noEndpointTouch && smin === 0 && smax === 1) return null;
        return [
          toPoint(a1, smin > 0 ? smin : 0, va),
          toPoint(a1, smax < 1 ? smax : 1, va)
        ];
      }
      return null;
    };
  }
});

// node_modules/martinez-polygon-clipping/src/index.js
var require_src = __commonJS({
  "node_modules/martinez-polygon-clipping/src/index.js"(exports, module) {
    var INTERSECTION = 0;
    var UNION = 1;
    var DIFFERENCE = 2;
    var XOR = 3;
    var EMPTY = [];
    var edgeType = require_edge_type();
    var Queue = require_tinyqueue();
    var Tree = require_bintrees().RBTree;
    var SweepEvent = require_sweep_event();
    var compareEvents = require_compare_events();
    var compareSegments = require_compare_segments();
    var intersection = require_segment_intersection();
    var equals = require_equals();
    var max = Math.max;
    var min = Math.min;
    function processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {
      var e1 = new SweepEvent(s1, false, void 0, isSubject);
      var e2 = new SweepEvent(s2, false, e1, isSubject);
      e1.otherEvent = e2;
      e1.contourId = e2.contourId = depth;
      if (compareEvents(e1, e2) > 0) {
        e2.left = true;
      } else {
        e1.left = true;
      }
      bbox[0] = min(bbox[0], s1[0]);
      bbox[1] = min(bbox[1], s1[1]);
      bbox[2] = max(bbox[2], s1[0]);
      bbox[3] = max(bbox[3], s1[1]);
      eventQueue.push(e1);
      eventQueue.push(e2);
    }
    var contourId = 0;
    function processPolygon(polygon, isSubject, depth, queue, bbox) {
      var i, len;
      if (typeof polygon[0][0] === "number") {
        for (i = 0, len = polygon.length - 1; i < len; i++) {
          processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);
        }
      } else {
        for (i = 0, len = polygon.length; i < len; i++) {
          contourId++;
          processPolygon(polygon[i], isSubject, contourId, queue, bbox);
        }
      }
    }
    function fillQueue(subject, clipping, sbbox, cbbox) {
      var eventQueue = new Queue(null, compareEvents);
      contourId = 0;
      processPolygon(subject, true, 0, eventQueue, sbbox);
      processPolygon(clipping, false, 0, eventQueue, cbbox);
      return eventQueue;
    }
    function computeFields(event2, prev, sweepLine, operation) {
      if (prev === null) {
        event2.inOut = false;
        event2.otherInOut = true;
      } else if (event2.isSubject === prev.isSubject) {
        event2.inOut = !prev.inOut;
        event2.otherInOut = prev.otherInOut;
      } else {
        event2.inOut = !prev.otherInOut;
        event2.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
      }
      if (prev) {
        event2.prevInResult = !inResult(prev, operation) || prev.isVertical() ? prev.prevInResult : prev;
      }
      event2.inResult = inResult(event2, operation);
    }
    function inResult(event2, operation) {
      switch (event2.type) {
        case edgeType.NORMAL:
          switch (operation) {
            case INTERSECTION:
              return !event2.otherInOut;
            case UNION:
              return event2.otherInOut;
            case DIFFERENCE:
              return event2.isSubject && event2.otherInOut || !event2.isSubject && !event2.otherInOut;
            case XOR:
              return true;
          }
        case edgeType.SAME_TRANSITION:
          return operation === INTERSECTION || operation === UNION;
        case edgeType.DIFFERENT_TRANSITION:
          return operation === DIFFERENCE;
        case edgeType.NON_CONTRIBUTING:
          return false;
      }
      return false;
    }
    function possibleIntersection(se1, se2, queue) {
      var inter = intersection(
        se1.point,
        se1.otherEvent.point,
        se2.point,
        se2.otherEvent.point
      );
      var nintersections = inter ? inter.length : 0;
      if (nintersections === 0) return 0;
      if (nintersections === 1 && (equals(se1.point, se2.point) || equals(se1.otherEvent.point, se2.otherEvent.point))) {
        return 0;
      }
      if (nintersections === 2 && se1.isSubject === se2.isSubject) {
        if (se1.contourId === se2.contourId) {
          console.warn(
            "Edges of the same polygon overlap",
            se1.point,
            se1.otherEvent.point,
            se2.point,
            se2.otherEvent.point
          );
        }
        return 0;
      }
      if (nintersections === 1) {
        if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
          divideSegment(se1, inter[0], queue);
        }
        if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
          divideSegment(se2, inter[0], queue);
        }
        return 1;
      }
      var events = [];
      var leftCoincide = false;
      var rightCoincide = false;
      if (equals(se1.point, se2.point)) {
        leftCoincide = true;
      } else if (compareEvents(se1, se2) === 1) {
        events.push(se2, se1);
      } else {
        events.push(se1, se2);
      }
      if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
        rightCoincide = true;
      } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {
        events.push(se2.otherEvent, se1.otherEvent);
      } else {
        events.push(se1.otherEvent, se2.otherEvent);
      }
      if (leftCoincide && rightCoincide || leftCoincide) {
        se1.type = edgeType.NON_CONTRIBUTING;
        se2.type = se1.inOut === se2.inOut ? edgeType.SAME_TRANSITION : edgeType.DIFFERENT_TRANSITION;
        if (leftCoincide && !rightCoincide) {
          divideSegment(events[0].otherEvent, events[1].point, queue);
        }
        return 2;
      }
      if (rightCoincide) {
        divideSegment(events[0], events[1].point, queue);
        return 3;
      }
      if (events[0] !== events[3].otherEvent) {
        divideSegment(events[0], events[1].point, queue);
        divideSegment(events[1], events[2].point, queue);
        return 3;
      }
      divideSegment(events[0], events[1].point, queue);
      divideSegment(events[3].otherEvent, events[2].point, queue);
      return 3;
    }
    function divideSegment(se, p, queue) {
      var r = new SweepEvent(p, false, se, se.isSubject);
      var l = new SweepEvent(p, true, se.otherEvent, se.isSubject);
      if (equals(se.point, se.otherEvent.point)) {
        console.warn("what is that?", se);
      }
      r.contourId = l.contourId = se.contourId;
      if (compareEvents(l, se.otherEvent) > 0) {
        se.otherEvent.left = true;
        l.left = false;
      }
      se.otherEvent.otherEvent = l;
      se.otherEvent = r;
      queue.push(l);
      queue.push(r);
      return queue;
    }
    function subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {
      var sortedEvents = [];
      var prev, next;
      var sweepLine = new Tree(compareSegments);
      var sortedEvents = [];
      var rightbound = min(sbbox[2], cbbox[2]);
      var prev, next;
      while (eventQueue.length) {
        var event2 = eventQueue.pop();
        sortedEvents.push(event2);
        if (operation === INTERSECTION && event2.point[0] > rightbound || operation === DIFFERENCE && event2.point[0] > sbbox[2]) {
          break;
        }
        if (event2.left) {
          sweepLine.insert(event2);
          next = sweepLine.findIter(event2);
          prev = sweepLine.findIter(event2);
          event2.iterator = sweepLine.findIter(event2);
          if (!prev || !next) {
            console.log("brute");
            var iterators = findIterBrute(sweepLine);
            prev = iterators[0];
            next = iterators[1];
          }
          if (prev.data() !== sweepLine.min()) {
            prev.prev();
          } else {
            prev = sweepLine.iterator();
            prev.prev();
            prev.next();
          }
          next.next();
          computeFields(event2, prev.data(), sweepLine, operation);
          if (next.data()) {
            if (possibleIntersection(event2, next.data(), eventQueue) === 2) {
              computeFields(event2, prev.data(), sweepLine, operation);
              computeFields(event2, next.data(), sweepLine, operation);
            }
          }
          if (prev.data()) {
            if (possibleIntersection(prev.data(), event2, eventQueue) === 2) {
              var prevprev = sweepLine.findIter(prev.data());
              if (prevprev.data() !== sweepLine.min()) {
                prevprev.prev();
              } else {
                prevprev = sweepLine.findIter(sweepLine.max());
                prevprev.next();
              }
              computeFields(prev.data(), prevprev.data(), sweepLine, operation);
              computeFields(event2, prev.data(), sweepLine, operation);
            }
          }
        } else {
          event2 = event2.otherEvent;
          next = sweepLine.findIter(event2);
          prev = sweepLine.findIter(event2);
          if (!(prev && next)) continue;
          if (prev.data() !== sweepLine.min()) {
            prev.prev();
          } else {
            prev = sweepLine.iterator();
            prev.prev();
            prev.next();
          }
          next.next();
          sweepLine.remove(event2);
          if (next.data() && prev.data()) {
            possibleIntersection(prev.data(), next.data(), eventQueue);
          }
        }
      }
      return sortedEvents;
    }
    function findIterBrute(sweepLine, q) {
      var prev = sweepLine.iterator();
      var next = sweepLine.iterator();
      var it = sweepLine.iterator(), data;
      while ((data = it.next()) !== null) {
        prev.next();
        next.next();
        if (data === event) {
          break;
        }
      }
      return [prev, next];
    }
    function swap(arr, i, n) {
      var temp = arr[i];
      arr[i] = arr[n];
      arr[n] = temp;
    }
    function changeOrientation(contour) {
      return contour.reverse();
    }
    function isArray(arr) {
      return Object.prototype.toString.call(arr) === "[object Array]";
    }
    function addHole(contour, idx) {
      if (isArray(contour[0]) && !isArray(contour[0][0])) {
        contour = [contour];
      }
      contour[idx] = [];
      return contour;
    }
    function orderEvents(sortedEvents) {
      var event2, i, len;
      var resultEvents = [];
      for (i = 0, len = sortedEvents.length; i < len; i++) {
        event2 = sortedEvents[i];
        if (event2.left && event2.inResult || !event2.left && event2.otherEvent.inResult) {
          resultEvents.push(event2);
        }
      }
      var sorted = false;
      while (!sorted) {
        sorted = true;
        for (i = 0, len = resultEvents.length; i < len; i++) {
          if (i + 1 < len && compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {
            swap(resultEvents, i, i + 1);
            sorted = false;
          }
        }
      }
      for (i = 0, len = resultEvents.length; i < len; i++) {
        resultEvents[i].pos = i;
      }
      for (i = 0, len = resultEvents.length; i < len; i++) {
        if (!resultEvents[i].left) {
          var temp = resultEvents[i].pos;
          resultEvents[i].pos = resultEvents[i].otherEvent.pos;
          resultEvents[i].otherEvent.pos = temp;
        }
      }
      return resultEvents;
    }
    function connectEdges(sortedEvents) {
      var i, len;
      var resultEvents = orderEvents(sortedEvents);
      var processed = Array(resultEvents.length);
      var result = [];
      var depth = [];
      var holeOf = [];
      var isHole = {};
      for (i = 0, len = resultEvents.length; i < len; i++) {
        if (processed[i]) continue;
        var contour = [];
        result.push(contour);
        var ringId = result.length - 1;
        depth.push(0);
        holeOf.push(-1);
        if (resultEvents[i].prevInResult) {
          var lowerContourId = resultEvents[i].prevInResult.contourId;
          if (!resultEvents[i].prevInResult.resultInOut) {
            addHole(result[lowerContourId], ringId);
            holeOf[ringId] = lowerContourId;
            depth[ringId] = depth[lowerContourId] + 1;
            isHole[ringId] = true;
          } else if (isHole[lowerContourId]) {
            addHole(result[holeOf[lowerContourId]], ringId);
            holeOf[ringId] = holeOf[lowerContourId];
            depth[ringId] = depth[lowerContourId];
            isHole[ringId] = true;
          }
        }
        var pos = i;
        var initial = resultEvents[i].point;
        contour.push(initial);
        while (pos >= i) {
          processed[pos] = true;
          if (resultEvents[pos].left) {
            resultEvents[pos].resultInOut = false;
            resultEvents[pos].contourId = ringId;
          } else {
            resultEvents[pos].otherEvent.resultInOut = true;
            resultEvents[pos].otherEvent.contourId = ringId;
          }
          pos = resultEvents[pos].pos;
          processed[pos] = true;
          contour.push(resultEvents[pos].point);
          pos = nextPos(pos, resultEvents, processed);
        }
        pos = pos === -1 ? i : pos;
        processed[pos] = processed[resultEvents[pos].pos] = true;
        resultEvents[pos].otherEvent.resultInOut = true;
        resultEvents[pos].otherEvent.contourId = ringId;
        if (depth[ringId] & 1) {
          changeOrientation(contour);
        }
      }
      return result;
    }
    function nextPos(pos, resultEvents, processed) {
      var newPos = pos + 1;
      var length = resultEvents.length;
      while (newPos < length && equals(resultEvents[newPos].point, resultEvents[pos].point)) {
        if (!processed[newPos]) {
          return newPos;
        } else {
          newPos = newPos + 1;
        }
      }
      newPos = pos - 1;
      while (processed[newPos]) {
        newPos = newPos - 1;
      }
      return newPos;
    }
    function trivialOperation(subject, clipping, operation) {
      var result = null;
      if (subject.length * clipping.length === 0) {
        if (operation === INTERSECTION) {
          result = EMPTY;
        } else if (operation === DIFFERENCE) {
          result = subject;
        } else if (operation === UNION || operation === XOR) {
          result = subject.length === 0 ? clipping : subject;
        }
      }
      return result;
    }
    function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
      var result = null;
      if (sbbox[0] > cbbox[2] || cbbox[0] > sbbox[2] || sbbox[1] > cbbox[3] || cbbox[1] > sbbox[3]) {
        if (operation === INTERSECTION) {
          result = EMPTY;
        } else if (operation === DIFFERENCE) {
          result = subject;
        } else if (operation === UNION || operation === XOR) {
          result = subject.concat(clipping);
        }
      }
      return result;
    }
    function boolean(subject, clipping, operation) {
      var trivial = trivialOperation(subject, clipping, operation);
      if (trivial) {
        return trivial === EMPTY ? null : trivial;
      }
      var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
      var cbbox = [Infinity, Infinity, -Infinity, -Infinity];
      var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);
      trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);
      if (trivial) {
        return trivial === EMPTY ? null : trivial;
      }
      var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);
      return connectEdges(sortedEvents);
    }
    module.exports = boolean;
    module.exports.union = function(subject, clipping) {
      return boolean(subject, clipping, UNION);
    };
    module.exports.diff = function(subject, clipping) {
      return boolean(subject, clipping, DIFFERENCE);
    };
    module.exports.xor = function(subject, clipping) {
      return boolean(subject, clipping, XOR);
    };
    module.exports.intersection = function(subject, clipping) {
      return boolean(subject, clipping, INTERSECTION);
    };
    module.exports.operations = {
      INTERSECTION,
      DIFFERENCE,
      UNION,
      XOR
    };
    module.exports.fillQueue = fillQueue;
    module.exports.computeFields = computeFields;
    module.exports.subdivideSegments = subdivideSegments;
    module.exports.divideSegment = divideSegment;
    module.exports.possibleIntersection = possibleIntersection;
  }
});

// node_modules/martinez-polygon-clipping/index.js
var require_martinez_polygon_clipping = __commonJS({
  "node_modules/martinez-polygon-clipping/index.js"(exports, module) {
    module.exports = require_src();
  }
});

// node_modules/polygon-offset/src/utils.js
var require_utils = __commonJS({
  "node_modules/polygon-offset/src/utils.js"(exports, module) {
    var isArray = module.exports.isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) === "[object Array]";
    };
    var isNonEmptyArray = module.exports.isNonEmptyArray = function(arr) {
      return isArray(arr) && arr.length;
    };
    module.exports.equals = function equals(p1, p2) {
      return p1[0] === p2[0] && p1[1] === p2[1];
    };
    module.exports.orientRings = function orientRings(coordinates, depth, isHole) {
      depth = depth || 0;
      var i, len;
      if (isNonEmptyArray(coordinates) && typeof coordinates[0][0] === "number") {
        var area = 0;
        var ring = coordinates;
        for (i = 0, len = ring.length; i < len; i++) {
          var pt1 = ring[i];
          var pt2 = ring[(i + 1) % len];
          area += pt1[0] * pt2[1];
          area -= pt2[0] * pt1[1];
        }
        if (!isHole && area > 0 || isHole && area < 0) {
          ring.reverse();
        }
      } else {
        for (i = 0, len = coordinates.length; i < len; i++) {
          orientRings(coordinates[i], depth + 1, i > 0);
        }
      }
      if (depth === 0 && isNonEmptyArray(coordinates) && isNonEmptyArray(coordinates[0]) && typeof coordinates[0][0][0] === "number") {
        var clone = coordinates[0].slice(0, 1)[0];
        coordinates[0].pop();
        coordinates[0].push([clone[0], clone[1]]);
      }
      return coordinates;
    };
  }
});

// node_modules/polygon-offset/src/offset.js
var require_offset = __commonJS({
  "node_modules/polygon-offset/src/offset.js"(exports, module) {
    var Edge = require_edge();
    var martinez = require_martinez_polygon_clipping();
    var utils = require_utils();
    var isArray = utils.isArray;
    var equals = utils.equals;
    var orientRings = utils.orientRings;
    function Offset(vertices, arcSegments) {
      this.vertices = null;
      this.edges = null;
      this._closed = false;
      this._distance = 0;
      if (vertices) {
        this.data(vertices);
      }
      this._arcSegments = arcSegments !== void 0 ? arcSegments : 5;
    }
    Offset.prototype.data = function(vertices) {
      this._edges = [];
      if (!isArray(vertices)) {
        throw new Error("Offset requires at least one coodinate to work with");
      }
      if (isArray(vertices) && typeof vertices[0] === "number") {
        this.vertices = vertices;
      } else {
        this.vertices = orientRings(vertices);
        this._processContour(this.vertices, this._edges);
      }
      return this;
    };
    Offset.prototype._processContour = function(contour, edges) {
      var i, len;
      if (isArray(contour[0]) && typeof contour[0][0] === "number") {
        len = contour.length;
        if (equals(contour[0], contour[len - 1])) {
          len -= 1;
        }
        for (i = 0; i < len; i++) {
          edges.push(new Edge(contour[i], contour[(i + 1) % len]));
        }
      } else {
        for (i = 0, len = contour.length; i < len; i++) {
          edges.push([]);
          this._processContour(contour[i], edges[edges.length - 1]);
        }
      }
    };
    Offset.prototype.arcSegments = function(arcSegments) {
      this._arcSegments = arcSegments;
      return this;
    };
    Offset.prototype.validate = function(vertices) {
      var len = vertices.length;
      if (typeof vertices[0] === "number") return [vertices];
      if (vertices[0][0] === vertices[len - 1][0] && vertices[0][1] === vertices[len - 1][1]) {
        if (len > 1) {
          vertices = vertices.slice(0, len - 1);
          this._closed = true;
        }
      }
      return vertices;
    };
    Offset.prototype.createArc = function(vertices, center, radius, startVertex, endVertex, segments, outwards) {
      var PI2 = Math.PI * 2, startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]), endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);
      if (segments % 2 === 0) {
        segments -= 1;
      }
      if (startAngle < 0) {
        startAngle += PI2;
      }
      if (endAngle < 0) {
        endAngle += PI2;
      }
      var angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI2 - endAngle, segmentAngle = (outwards ? -angle : PI2 - angle) / segments;
      vertices.push(startVertex);
      for (var i = 1; i < segments; ++i) {
        angle = startAngle + segmentAngle * i;
        vertices.push([
          center[0] + Math.cos(angle) * radius,
          center[1] + Math.sin(angle) * radius
        ]);
      }
      vertices.push(endVertex);
      return vertices;
    };
    Offset.prototype.distance = function(dist, units) {
      this._distance = dist || 0;
      return this;
    };
    Offset.degreesToUnits = function(degrees, units) {
      switch (units) {
        case "miles":
          degrees = degrees / 69.047;
          break;
        case "feet":
          degrees = degrees / 364568;
          break;
        case "kilometers":
          degrees = degrees / 111.12;
          break;
        case "meters":
        case "metres":
          degrees = degrees / 111120;
          break;
        case "degrees":
        case "pixels":
        default:
          break;
      }
      return degrees;
    };
    Offset.prototype.ensureLastPoint = function(vertices) {
      if (!equals(vertices[0], vertices[vertices.length - 1])) {
        vertices.push([
          vertices[0][0],
          vertices[0][1]
        ]);
      }
      return vertices;
    };
    Offset.prototype.offset = function(dist) {
      this.distance(dist);
      return this._distance === 0 ? this.vertices : this._distance > 0 ? this.margin(this._distance) : this.padding(-this._distance);
    };
    Offset.prototype._offsetSegment = function(v1, v2, e1, dist) {
      var vertices = [];
      var offsets = [
        e1.offset(e1._inNormal[0] * dist, e1._inNormal[1] * dist),
        e1.inverseOffset(e1._outNormal[0] * dist, e1._outNormal[1] * dist)
      ];
      for (var i = 0, len = 2; i < len; i++) {
        var thisEdge = offsets[i], prevEdge = offsets[(i + len - 1) % len];
        this.createArc(
          vertices,
          i === 0 ? v1 : v2,
          // edges[i].current, // p1 or p2
          dist,
          prevEdge.next,
          thisEdge.current,
          this._arcSegments,
          true
        );
      }
      return vertices;
    };
    Offset.prototype.margin = function(dist) {
      this.distance(dist);
      if (typeof this.vertices[0] === "number") {
        return this.offsetPoint(this._distance);
      }
      if (dist === 0) return this.vertices;
      var union = this.offsetLines(this._distance);
      union = martinez.union(this.vertices, union);
      return orientRings(union);
    };
    Offset.prototype.padding = function(dist) {
      this.distance(dist);
      if (this._distance === 0) return this.ensureLastPoint(this.vertices);
      if (this.vertices.length === 2 && typeof this.vertices[0] === "number") {
        return this.vertices;
      }
      var union = this.offsetLines(this._distance);
      var diff = martinez.diff(this.vertices, union);
      return orientRings(diff);
    };
    Offset.prototype.offsetLine = function(dist) {
      if (dist === 0) return this.vertices;
      return orientRings(this.offsetLines(dist));
    };
    Offset.prototype.offsetLines = function(dist) {
      if (dist < 0) throw new Error("Cannot apply negative margin to the line");
      var union;
      this.distance(dist);
      if (isArray(this.vertices[0]) && typeof this.vertices[0][0] !== "number") {
        for (var i = 0, len = this._edges.length; i < len; i++) {
          union = i === 0 ? this.offsetContour(this.vertices[i], this._edges[i]) : martinez.union(union, this.offsetContour(this.vertices[i], this._edges[i]));
        }
      } else {
        union = this.vertices.length === 1 ? this.offsetPoint() : this.offsetContour(this.vertices, this._edges);
      }
      return union;
    };
    Offset.prototype.offsetContour = function(curve, edges) {
      var union, i, len;
      if (isArray(curve[0]) && typeof curve[0][0] === "number") {
        for (i = 0, len = curve.length - 1; i < len; i++) {
          var segment = this.ensureLastPoint(
            this._offsetSegment(curve[i], curve[i + 1], edges[i], this._distance)
          );
          union = i === 0 ? [this.ensureLastPoint(segment)] : martinez.union(union, this.ensureLastPoint(segment));
        }
      } else {
        for (i = 0, len = edges.length; i < len; i++) {
          union = i === 0 ? this.offsetContour(curve[i], edges[i]) : martinez.union(union, this.offsetContour(curve[i], edges[i]));
        }
      }
      return union;
    };
    Offset.prototype.offsetPoint = function(distance) {
      this.distance(distance);
      var vertices = this._arcSegments * 2;
      var points = [];
      var center = this.vertices;
      var radius = this._distance;
      var angle = 0;
      if (vertices % 2 === 0) vertices++;
      for (var i = 0; i < vertices; i++) {
        angle += 2 * Math.PI / vertices;
        points.push([
          center[0] + radius * Math.cos(angle),
          center[1] + radius * Math.sin(angle)
        ]);
      }
      return orientRings([this.ensureLastPoint(points)]);
    };
    Offset.orientRings = orientRings;
    module.exports = Offset;
  }
});
export default require_offset();
//# sourceMappingURL=polygon-offset.js.map
