{
  "version": 3,
  "sources": ["../../polygon-offset/src/edge.js", "../../martinez-polygon-clipping/src/edge_type.js", "../../tinyqueue/index.js", "../../bintrees/lib/treebase.js", "../../bintrees/lib/rbtree.js", "../../bintrees/lib/bintree.js", "../../bintrees/index.js", "../../martinez-polygon-clipping/src/signed_area.js", "../../martinez-polygon-clipping/src/sweep_event.js", "../../martinez-polygon-clipping/src/compare_events.js", "../../martinez-polygon-clipping/src/equals.js", "../../martinez-polygon-clipping/src/compare_segments.js", "../../martinez-polygon-clipping/src/segment_intersection.js", "../../martinez-polygon-clipping/src/index.js", "../../martinez-polygon-clipping/index.js", "../../polygon-offset/src/utils.js", "../../polygon-offset/src/offset.js"],
  "sourcesContent": ["/**\n * Offset edge of the polygon\n *\n * @param  {Object} current\n * @param  {Object} next\n * @constructor\n */\nfunction Edge(current, next) {\n\n  /**\n   * @type {Object}\n   */\n  this.current = current;\n\n  /**\n   * @type {Object}\n   */\n  this.next = next;\n\n  /**\n   * @type {Object}\n   */\n  this._inNormal  = this.inwardsNormal();\n\n  /**\n   * @type {Object}\n   */\n  this._outNormal = this.outwardsNormal();\n}\n\n/**\n * Creates outwards normal\n * @return {Object}\n */\nEdge.prototype.outwardsNormal = function() {\n  var inwards = this.inwardsNormal();\n  return [\n    -inwards[0],\n    -inwards[1]\n  ];\n};\n\n/**\n * Creates inwards normal\n * @return {Object}\n */\nEdge.prototype.inwardsNormal = function() {\n  var dx = this.next[0] - this.current[0],\n      dy = this.next[1] - this.current[1],\n      edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n  if (edgeLength === 0) throw new Error('Vertices overlap');\n\n  return [\n    -dy / edgeLength,\n     dx / edgeLength\n  ];\n};\n\n/**\n * Offsets the edge by dx, dy\n * @param  {Number} dx\n * @param  {Number} dy\n * @return {Edge}\n */\nEdge.prototype.offset = function(dx, dy) {\n  return Edge.offsetEdge(this.current, this.next, dx, dy);\n};\n\n\n/**\n * @param  {Number} dx\n * @param  {Number} dy\n * @return {Edge}\n */\nEdge.prototype.inverseOffset = function(dx, dy) {\n  return Edge.offsetEdge(this.next, this.current, dx, dy);\n};\n\n\n/**\n * @static\n * @param  {Array.<Number>} current\n * @param  {Array.<Number>} next\n * @param  {Number}         dx\n * @param  {Number}         dy\n * @return {Edge}\n */\nEdge.offsetEdge = function(current, next, dx, dy) {\n  return new Edge([\n    current[0] + dx,\n    current[1] + dy\n  ], [\n    next[0] + dx,\n    next[1] + dy\n  ]);\n};\n\n\n/**\n *\n * @return {Edge}\n */\nEdge.prototype.inverse = function () {\n  return new Edge(this.next, this.current);\n};\n\n\nmodule.exports = Edge;\n", "module.exports = { \n  NORMAL:               0, \n  NON_CONTRIBUTING:     1, \n  SAME_TRANSITION:      2, \n  DIFFERENT_TRANSITION: 3\n};\n", "'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n", "\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n", "\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n", "\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n", "module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n", "/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nmodule.exports = function signedArea(p0, p1, p2) {\n  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n};\n", "var signedArea = require('./signed_area');\nvar EdgeType   = require('./edge_type');\n\n\n/**\n * Sweepline event\n *\n * @param {Array.<Number>}  point\n * @param {Boolean}         left\n * @param {SweepEvent=}     otherEvent\n * @param {Boolean}         isSubject\n * @param {Number}          edgeType\n */\nfunction SweepEvent(point, left, otherEvent, isSubject, edgeType) {\n\n  /**\n   * Is left endpoint?\n   * @type {Boolean}\n   */\n  this.left = left;\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this.point = point;\n\n  /**\n   * Other edge reference\n   * @type {SweepEvent}\n   */\n  this.otherEvent = otherEvent;\n\n  /**\n   * Belongs to source or clipping polygon\n   * @type {Boolean}\n   */\n  this.isSubject = isSubject;\n\n  /**\n   * Edge contribution type\n   * @type {Number}\n   */\n  this.type = edgeType || EdgeType.NORMAL;\n\n\n  /**\n   * In-out transition for the sweepline crossing polygon\n   * @type {Boolean}\n   */\n  this.inOut = false;\n\n\n  /**\n   * @type {Boolean}\n   */\n  this.otherInOut = false;\n\n  /**\n   * Previous event in result?\n   * @type {SweepEvent}\n   */\n  this.prevInResult = null;\n\n  /**\n   * Does event belong to result?\n   * @type {Boolean}\n   */\n  this.inResult = false;\n\n\n  // connection step\n\n  /**\n   * @type {Boolean}\n   */\n  this.resultInOut = false;\n}\n\n\nSweepEvent.prototype = {\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow: function(p) {\n    return this.left ?\n      signedArea (this.point, this.otherEvent.point, p) > 0 :\n      signedArea (this.otherEvent.point, this.point, p) > 0;\n  },\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove: function(p) {\n    return !this.isBelow(p);\n  },\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical: function() {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n};\n\nmodule.exports = SweepEvent;\n", "var signedArea = require('./signed_area');\n// var equals = require('./equals');\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nmodule.exports = function sweepEventsComp(e1, e2) {\n  var p1 = e1.point;\n  var p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n};\n\n\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  // uncomment this if you want to play with multipolygons\n  // if (e1.isSubject === e2.isSubject) {\n  //   if(equals(e1.point, e2.point) && e1.contourId === e2.contourId) {\n  //     return 0;\n  //   } else {\n  //     return e1.contourId > e2.contourId ? 1 : -1;\n  //   }\n  // }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n", "module.exports = function equals(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};", "var signedArea    = require('./signed_area');\nvar compareEvents = require('./compare_events');\nvar equals        = require('./equals');\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nmodule.exports = function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    if (equals(le1.point, le2.point)) {\n      if (equals(le1.otherEvent.point, le2.otherEvent.point)) {\n        return 0;\n      } else {\n        return le1.contourId > le2.contourId ? 1 : -1;\n      }\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n};\n", "var EPSILON = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction krossProduct(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nmodule.exports = function(a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  var va = [a2[0] - a1[0], a2[1] - a1[1]];\n  var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  var e = [b1[0] - a1[0], b1[1] - a1[1]];\n  var kross = krossProduct(va, vb);\n  var sqrKross = kross * kross;\n  var sqrLenA = dotProduct(va, va);\n  var sqrLenB = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    var s = krossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    var t = krossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    return noEndpointTouch ? null : [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  var sqrLenE = dotProduct(e, e);\n  kross = krossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {\n    // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  var sa = dotProduct(va, e) / sqrLenA;\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\n  var smin = Math.min(sa, sb);\n  var smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va),\n    ];\n  }\n\n  return null;\n};\n", "var INTERSECTION    = 0;\nvar UNION           = 1;\nvar DIFFERENCE      = 2;\nvar XOR             = 3;\n\nvar EMPTY           = [];\n\nvar edgeType        = require('./edge_type');\n\nvar Queue           = require('tinyqueue');\nvar Tree            = require('bintrees').RBTree;\nvar SweepEvent      = require('./sweep_event');\n\nvar compareEvents   = require('./compare_events');\nvar compareSegments = require('./compare_segments');\nvar intersection    = require('./segment_intersection');\nvar equals          = require('./equals');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// global.Tree = Tree;\n// global.compareSegments = compareSegments;\n// global.SweepEvent = SweepEvent;\n// global.signedArea = require('./signed_area');\n\n/**\n * @param  {<Array.<Number>} s1\n * @param  {<Array.<Number>} s2\n * @param  {Boolean}         isSubject\n * @param  {Queue}           eventQueue\n * @param  {Array.<Number>}  bbox\n */\nfunction processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {\n  // Possible degenerate condition.\n  // if (equals(s1, s2)) return;\n\n  var e1 = new SweepEvent(s1, false, undefined, isSubject);\n  var e2 = new SweepEvent(s2, false, e1,        isSubject);\n  e1.otherEvent = e2;\n\n  e1.contourId = e2.contourId = depth;\n\n  if (compareEvents(e1, e2) > 0) {\n    e2.left = true;\n  } else {\n    e1.left = true;\n  }\n\n  bbox[0] = min(bbox[0], s1[0]);\n  bbox[1] = min(bbox[1], s1[1]);\n  bbox[2] = max(bbox[2], s1[0]);\n  bbox[3] = max(bbox[3], s1[1]);\n\n  // Pushing it so the queue is sorted from left to right,\n  // with object on the left having the highest priority.\n  eventQueue.push(e1);\n  eventQueue.push(e2);\n}\n\nvar contourId = 0;\n\nfunction processPolygon(polygon, isSubject, depth, queue, bbox) {\n  var i, len;\n  if (typeof polygon[0][0] === 'number') {\n    for (i = 0, len = polygon.length - 1; i < len; i++) {\n      processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);\n    }\n  } else {\n    for (i = 0, len = polygon.length; i < len; i++) {\n      contourId++;\n      processPolygon(polygon[i], isSubject, contourId, queue, bbox);\n    }\n  }\n}\n\n\nfunction fillQueue(subject, clipping, sbbox, cbbox) {\n  var eventQueue = new Queue(null, compareEvents);\n  contourId = 0;\n\n  processPolygon(subject,  true,  0, eventQueue, sbbox);\n  processPolygon(clipping, false, 0, eventQueue, cbbox);\n\n  return eventQueue;\n}\n\n\nfunction computeFields(event, prev, sweepLine, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else if (event.isSubject === prev.isSubject) {\n    event.inOut      = !prev.inOut;\n    event.otherInOut = prev.otherInOut;\n\n  // previous line segment in sweepline belongs to the clipping polygon\n  } else {\n    event.inOut      = !prev.otherInOut;\n    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n  }\n\n  // compute prevInResult field\n  if (prev) {\n    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?\n       prev.prevInResult : prev;\n  }\n  // check if the line segment belongs to the Boolean operation\n  event.inResult = inResult(event, operation);\n}\n\n\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case edgeType.NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          return (event.isSubject && event.otherInOut) ||\n                 (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n    case edgeType.SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case edgeType.DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case edgeType.NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nfunction possibleIntersection(se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n\n  var inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  var nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject){\n    if(se1.contourId === se2.contourId){\n    console.warn('Edges of the same polygon overlap',\n      se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  var events        = [];\n  var leftCoincide  = false;\n  var rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se1.type = edgeType.NON_CONTRIBUTING;\n    se2.type = (se1.inOut === se2.inOut) ?\n      edgeType.SAME_TRANSITION :\n      edgeType.DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[0].otherEvent, events[1].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}\n\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nfunction divideSegment(se, p, queue)  {\n  var r = new SweepEvent(p, false, se,            se.isSubject);\n  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that?', se);\n  }\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}\n\n\n/* eslint-disable no-unused-vars, no-debugger */\nfunction iteratorEquals(it1, it2) {\n  return it1._cursor === it2._cursor;\n}\n\n\nfunction _renderSweepLine(sweepLine, pos, event) {\n  var map = window.map;\n  if (!map) return;\n  if (window.sws) window.sws.forEach(function(p) {\n    map.removeLayer(p);\n  });\n  window.sws = [];\n  sweepLine.each(function(e) {\n    var poly = L.polyline([e.point.slice().reverse(), e.otherEvent.point.slice().reverse()], { color: 'green' }).addTo(map);\n    window.sws.push(poly);\n  });\n\n  if (window.vt) map.removeLayer(window.vt);\n  var v = pos.slice();\n  var b = map.getBounds();\n  window.vt = L.polyline([[b.getNorth(), v[0]], [b.getSouth(), v[0]]], {color: 'green', weight: 1}).addTo(map);\n\n  if (window.ps) map.removeLayer(window.ps);\n  window.ps = L.polyline([event.point.slice().reverse(), event.otherEvent.point.slice().reverse()], {color: 'black', weight: 9, opacity: 0.4}).addTo(map);\n  debugger;\n}\n/* eslint-enable no-unused-vars, no-debugger */\n\n\nfunction subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  var sortedEvents = [];\n  var prev, next;\n\n  var sweepLine = new Tree(compareSegments);\n  var sortedEvents = [];\n\n  var rightbound = min(sbbox[2], cbbox[2]);\n\n  var prev, next;\n\n  while (eventQueue.length) {\n    var event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      sweepLine.insert(event);\n      // _renderSweepLine(sweepLine, event.point, event);\n\n      next = sweepLine.findIter(event);\n      prev = sweepLine.findIter(event);\n      event.iterator = sweepLine.findIter(event);\n\n      // Cannot get out of the tree what we just put there\n      if (!prev || !next) {\n        console.log('brute');\n        var iterators = findIterBrute(sweepLine);\n        prev = iterators[0];\n        next = iterators[1];\n      }\n\n      if (prev.data() !== sweepLine.min()) {\n        prev.prev();\n      } else {\n        prev = sweepLine.iterator(); //findIter(sweepLine.max());\n        prev.prev();\n        prev.next();\n      }\n      next.next();\n\n      computeFields(event, prev.data(), sweepLine, operation);\n\n      if (next.data()) {\n        if (possibleIntersection(event, next.data(), eventQueue) === 2) {\n          computeFields(event, prev.data(), sweepLine, operation);\n          computeFields(event, next.data(), sweepLine, operation);\n        }\n      }\n\n      if (prev.data()) {\n        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {\n          var prevprev = sweepLine.findIter(prev.data());\n          if (prevprev.data() !== sweepLine.min()) {\n            prevprev.prev();\n          } else {\n            prevprev = sweepLine.findIter(sweepLine.max());\n            prevprev.next();\n          }\n          computeFields(prev.data(), prevprev.data(), sweepLine, operation);\n          computeFields(event, prev.data(), sweepLine, operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = sweepLine.findIter(event);\n      prev = sweepLine.findIter(event);\n\n      // _renderSweepLine(sweepLine, event.otherEvent.point, event);\n\n      if (!(prev && next)) continue;\n\n      if (prev.data() !== sweepLine.min()) {\n        prev.prev();\n      } else {\n        prev = sweepLine.iterator();\n        prev.prev(); // sweepLine.findIter(sweepLine.max());\n        prev.next();\n      }\n      next.next();\n      sweepLine.remove(event);\n\n      //_renderSweepLine(sweepLine, event.otherEvent.point, event);\n\n      if (next.data() && prev.data()) {\n        possibleIntersection(prev.data(), next.data(), eventQueue);\n      }\n    }\n  }\n  return sortedEvents;\n}\n\nfunction findIterBrute(sweepLine, q) {\n  var prev = sweepLine.iterator();\n  var next = sweepLine.iterator();\n  var it   = sweepLine.iterator(), data;\n  while((data = it.next()) !== null) {\n    prev.next();\n    next.next();\n    if (data === event) {\n      break;\n    }\n  }\n  return [prev, next];\n}\n\n\nfunction swap (arr, i, n) {\n  var temp = arr[i];\n  arr[i] = arr[n];\n  arr[n] = temp;\n}\n\n\nfunction changeOrientation(contour) {\n  return contour.reverse();\n}\n\n\nfunction isArray (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n}\n\n\nfunction addHole(contour, idx) {\n  if (isArray(contour[0]) && !isArray(contour[0][0])) {\n    contour = [contour];\n  }\n  contour[idx] = [];\n  return contour;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  var event, i, len;\n  var resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  var sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        swap(resultEvents, i, i + 1);\n        sorted = false;\n      }\n    }\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    resultEvents[i].pos = i;\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (!resultEvents[i].left) {\n      var temp = resultEvents[i].pos;\n      resultEvents[i].pos = resultEvents[i].otherEvent.pos;\n      resultEvents[i].otherEvent.pos = temp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nfunction connectEdges(sortedEvents) {\n  var i, len;\n  var resultEvents = orderEvents(sortedEvents);\n\n\n  // \"false\"-filled array\n  var processed = Array(resultEvents.length);\n  var result = [];\n\n  var depth  = [];\n  var holeOf = [];\n  var isHole = {};\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (processed[i]) continue;\n\n    var contour = [];\n    result.push(contour);\n\n    var ringId = result.length - 1;\n    depth.push(0);\n    holeOf.push(-1);\n\n\n    if (resultEvents[i].prevInResult) {\n      var lowerContourId = resultEvents[i].prevInResult.contourId;\n      if (!resultEvents[i].prevInResult.resultInOut) {\n        addHole(result[lowerContourId], ringId);\n        holeOf[ringId] = lowerContourId;\n        depth[ringId]  = depth[lowerContourId] + 1;\n        isHole[ringId] = true;\n      } else if (isHole[lowerContourId]) {\n        addHole(result[holeOf[lowerContourId]], ringId);\n        holeOf[ringId] = holeOf[lowerContourId];\n        depth[ringId]  = depth[lowerContourId];\n        isHole[ringId] = true;\n      }\n    }\n\n    var pos = i;\n    var initial = resultEvents[i].point;\n    contour.push(initial);\n\n    while (pos >= i) {\n      processed[pos] = true;\n\n      if (resultEvents[pos].left) {\n        resultEvents[pos].resultInOut = false;\n        resultEvents[pos].contourId   = ringId;\n      } else {\n        resultEvents[pos].otherEvent.resultInOut = true;\n        resultEvents[pos].otherEvent.contourId   = ringId;\n      }\n\n      pos = resultEvents[pos].pos;\n      processed[pos] = true;\n\n      contour.push(resultEvents[pos].point);\n      pos = nextPos(pos, resultEvents, processed);\n    }\n\n    pos = pos === -1 ? i : pos;\n\n    processed[pos] = processed[resultEvents[pos].pos] = true;\n    resultEvents[pos].otherEvent.resultInOut = true;\n    resultEvents[pos].otherEvent.contourId   = ringId;\n\n\n    // depth is even\n    /* eslint-disable no-bitwise */\n    if (depth[ringId] & 1) {\n      changeOrientation(contour);\n    }\n    /* eslint-enable no-bitwise */\n  }\n\n  return result;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Array.<Boolean>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed) {\n  var newPos = pos + 1;\n  var length = resultEvents.length;\n  while (newPos < length &&\n         equals(resultEvents[newPos].point, resultEvents[pos].point)) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else {\n      newPos = newPos + 1;\n    }\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos]) {\n    newPos = newPos - 1;\n  }\n  return newPos;\n}\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  var result = null;\n  if (subject.length * clipping.length === 0) {\n    if (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION || operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  var result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION || operation === XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nfunction boolean(subject, clipping, operation) {\n  var trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  return connectEdges(sortedEvents);\n}\n\n\nmodule.exports = boolean;\n\n\nmodule.exports.union = function(subject, clipping) {\n  return boolean(subject, clipping, UNION);\n};\n\n\nmodule.exports.diff = function(subject, clipping) {\n  return boolean(subject, clipping, DIFFERENCE);\n};\n\n\nmodule.exports.xor = function(subject, clipping) {\n  return boolean(subject, clipping, XOR);\n};\n\n\nmodule.exports.intersection = function(subject, clipping) {\n  return boolean(subject, clipping, INTERSECTION);\n};\n\n\n/**\n * @enum {Number}\n */\nmodule.exports.operations = {\n  INTERSECTION: INTERSECTION,\n  DIFFERENCE:   DIFFERENCE,\n  UNION:        UNION,\n  XOR:          XOR\n};\n\n\n// for testing\nmodule.exports.fillQueue            = fillQueue;\nmodule.exports.computeFields        = computeFields;\nmodule.exports.subdivideSegments    = subdivideSegments;\nmodule.exports.divideSegment        = divideSegment;\nmodule.exports.possibleIntersection = possibleIntersection;\n", "module.exports = require('./src/index');\n", "/**\n * @param  {*} arr\n * @return {Boolean}\n */\nvar isArray = module.exports.isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\n\n\n/**\n * @param  {*} arr\n * @return {Boolean}\n */\nvar isNonEmptyArray = module.exports.isNonEmptyArray = function (arr) {\n  return isArray(arr) && arr.length;\n};\n\n\n/**\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Boolean}\n */\nmodule.exports.equals = function equals(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};\n\n\n/**\n * @param  {*}       coordinates\n * @param  {Number=} depth\n * @return {*}\n */\nmodule.exports.orientRings = function orientRings(coordinates, depth, isHole) {\n  depth = depth || 0;\n  var i, len;\n  if (isNonEmptyArray(coordinates) && typeof coordinates[0][0] === 'number') {\n    var area = 0;\n    var ring = coordinates;\n\n    for (i = 0, len = ring.length; i < len; i++) {\n      var pt1 = ring[i];\n      var pt2 = ring[(i + 1) % len];\n      area += pt1[0] * pt2[1];\n      area -= pt2[0] * pt1[1];\n    }\n    if ((!isHole && area > 0) || (isHole && area < 0)) {\n      ring.reverse();\n    }\n  } else {\n    for (i = 0, len = coordinates.length; i < len; i++) {\n      orientRings(coordinates[i], depth + 1, i > 0);\n    }\n  }\n\n  if (depth === 0 && isNonEmptyArray(coordinates) && isNonEmptyArray(coordinates[0]) && typeof coordinates[0][0][0] === 'number') {\n    var clone = coordinates[0].slice(0, 1)[0];\n    coordinates[0].pop();\n    coordinates[0].push([clone[0], clone[1]]);\n  }\n\n  return coordinates;\n};", "var Edge     = require('./edge');\nvar martinez = require('martinez-polygon-clipping');\nvar utils    = require('./utils');\n\n\nvar isArray     = utils.isArray;\nvar equals      = utils.equals;\nvar orientRings = utils.orientRings;\n\n\n/**\n * Offset builder\n *\n * @param {Array.<Object>=} vertices\n * @param {Number=}        arcSegments\n * @constructor\n */\nfunction Offset(vertices, arcSegments) {\n\n  /**\n   * @type {Array.<Object>}\n   */\n  this.vertices = null;\n\n  /**\n   * @type {Array.<Edge>}\n   */\n  this.edges = null;\n\n  /**\n   * @type {Boolean}\n   */\n  this._closed = false;\n\n\n  /**\n   * @type {Number}\n   */\n  this._distance = 0;\n\n  if (vertices) {\n    this.data(vertices);\n  }\n\n  /**\n   * Segments in edge bounding arches\n   * @type {Number}\n   */\n  this._arcSegments = arcSegments !== undefined ? arcSegments : 5;\n}\n\n/**\n * Change data set\n * @param  {Array.<Array>} vertices\n * @return {Offset}\n */\nOffset.prototype.data = function(vertices) {\n  this._edges = [];\n  if (!isArray (vertices)) {\n    throw new Error('Offset requires at least one coodinate to work with');\n  }\n\n  if (isArray(vertices) && typeof vertices[0] === 'number') {\n    this.vertices = vertices;\n  } else {\n    this.vertices = orientRings(vertices);\n    this._processContour(this.vertices, this._edges);\n  }\n\n  return this;\n};\n\n\n/**\n * Recursively process contour to create normals\n * @param  {*} contour\n * @param  {Array} edges\n */\nOffset.prototype._processContour = function(contour, edges) {\n  var i, len;\n  if (isArray(contour[0]) && typeof contour[0][0] === 'number') {\n    len = contour.length;\n    if (equals(contour[0], contour[len - 1])) {\n      len -= 1; // otherwise we get division by zero in normals\n    }\n    for (i = 0; i < len; i++) {\n      edges.push(new Edge(contour[i], contour[(i + 1) % len]));\n    }\n  } else {\n    for (i = 0, len = contour.length; i < len; i++) {\n      edges.push([]);\n      this._processContour(contour[i], edges[edges.length - 1]);\n    }\n  }\n};\n\n\n/**\n * @param  {Number} arcSegments\n * @return {Offset}\n */\nOffset.prototype.arcSegments = function(arcSegments) {\n  this._arcSegments = arcSegments;\n  return this;\n};\n\n\n/**\n * Validates if the first and last points repeat\n * TODO: check CCW\n *\n * @param  {Array.<Object>} vertices\n */\nOffset.prototype.validate = function(vertices) {\n  var len = vertices.length;\n  if (typeof vertices[0] === 'number') return [vertices];\n  if (vertices[0][0] === vertices[len - 1][0] &&\n    vertices[0][1] === vertices[len - 1][1]) {\n    if (len > 1) {\n      vertices = vertices.slice(0, len - 1);\n      this._closed = true;\n    }\n  }\n  return vertices;\n};\n\n\n/**\n * Creates arch between two edges\n *\n * @param  {Array.<Object>} vertices\n * @param  {Object}         center\n * @param  {Number}         radius\n * @param  {Object}         startVertex\n * @param  {Object}         endVertex\n * @param  {Number}         segments\n * @param  {Boolean}        outwards\n */\nOffset.prototype.createArc = function(vertices, center, radius, startVertex,\n    endVertex, segments, outwards) {\n\n  var PI2 = Math.PI * 2,\n      startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]),\n      endAngle   = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);\n\n  // odd number please\n  if (segments % 2 === 0) {\n    segments -= 1;\n  }\n\n  if (startAngle < 0) {\n    startAngle += PI2;\n  }\n\n  if (endAngle < 0) {\n    endAngle += PI2;\n  }\n\n  var angle = ((startAngle > endAngle) ?\n               (startAngle - endAngle) :\n               (startAngle + PI2 - endAngle)),\n      segmentAngle = ((outwards) ? -angle : PI2 - angle) / segments;\n\n  vertices.push(startVertex);\n  for (var i = 1; i < segments; ++i) {\n    angle = startAngle + segmentAngle * i;\n    vertices.push([\n      center[0] + Math.cos(angle) * radius,\n      center[1] + Math.sin(angle) * radius\n    ]);\n  }\n  vertices.push(endVertex);\n  return vertices;\n};\n\n\n/**\n * @param  {Number}  dist\n * @param  {String=} units\n * @return {Offset}\n */\nOffset.prototype.distance = function(dist, units) {\n  this._distance = dist || 0;\n  return this;\n};\n\n\n/**\n * @static\n * @param  {Number}  degrees\n * @param  {String=} units\n * @return {Number}\n */\nOffset.degreesToUnits = function(degrees, units) {\n  switch (units) {\n    case 'miles':\n      degrees = degrees / 69.047;\n    break;\n    case 'feet':\n      degrees = degrees / 364568.0;\n      break;\n    case 'kilometers':\n      degrees = degrees / 111.12;\n      break;\n    case 'meters':\n    case 'metres':\n      degrees = degrees / 111120.0;\n      break;\n    case 'degrees':\n    case 'pixels':\n    default:\n      break;\n  }\n  return degrees;\n};\n\n\n/**\n * @param  {Array.<Object>} vertices\n * @return {Array.<Object>}\n */\nOffset.prototype.ensureLastPoint = function(vertices) {\n  if (!equals(vertices[0], vertices[vertices.length - 1])) {\n    vertices.push([\n      vertices[0][0],\n      vertices[0][1]\n    ]);\n  }\n  return vertices;\n};\n\n\n/**\n * Decides by the sign if it's a padding or a margin\n *\n * @param  {Number} dist\n * @return {Array.<Object>}\n */\nOffset.prototype.offset = function(dist) {\n  this.distance(dist);\n  return this._distance === 0 ? this.vertices :\n      (this._distance > 0 ? this.margin(this._distance) :\n        this.padding(-this._distance));\n};\n\n\n/**\n * @param  {Array.<Array.<Number>>} vertices\n * @param  {Array.<Number>}         pt1\n * @param  {Array.<Number>}         pt2\n * @param  {Number}                 dist\n * @return {Array.<Array.<Number>>}\n */\nOffset.prototype._offsetSegment = function(v1, v2, e1, dist) {\n  var vertices = [];\n  var offsets = [\n    e1.offset(e1._inNormal[0] * dist, e1._inNormal[1] * dist),\n    e1.inverseOffset(e1._outNormal[0] * dist, e1._outNormal[1] * dist)\n  ];\n\n  for (var i = 0, len = 2; i < len; i++) {\n    var thisEdge = offsets[i],\n        prevEdge = offsets[(i + len - 1) % len];\n    this.createArc(\n              vertices,\n              i === 0 ? v1 : v2, // edges[i].current, // p1 or p2\n              dist,\n              prevEdge.next,\n              thisEdge.current,\n              this._arcSegments,\n              true\n            );\n  }\n\n  return vertices;\n};\n\n\n/**\n * @param  {Number} dist\n * @return {Array.<Number>}\n */\nOffset.prototype.margin = function(dist) {\n  this.distance(dist);\n\n  if (typeof this.vertices[0] === 'number') { // point\n    return this.offsetPoint(this._distance);\n  }\n\n  if (dist === 0) return this.vertices;\n\n  var union = this.offsetLines(this._distance);\n  //return union;\n  union = martinez.union(this.vertices, union);\n  return orientRings(union);\n};\n\n\n/**\n * @param  {Number} dist\n * @return {Array.<Number>}\n */\nOffset.prototype.padding = function(dist) {\n  this.distance(dist);\n\n  if (this._distance === 0) return this.ensureLastPoint(this.vertices);\n  if (this.vertices.length === 2 && typeof this.vertices[0] === 'number') {\n    return this.vertices;\n  }\n\n  var union = this.offsetLines(this._distance);\n  var diff = martinez.diff(this.vertices, union);\n  return orientRings(diff);\n};\n\n\n/**\n * Creates margin polygon\n * @param  {Number} dist\n * @return {Array.<Object>}\n */\nOffset.prototype.offsetLine = function(dist) {\n  if (dist === 0) return this.vertices;\n  return orientRings(this.offsetLines(dist));\n};\n\n\n/**\n * Just offsets lines, no fill\n * @param  {Number} dist\n * @return {Array.<Array.<Array.<Number>>>}\n */\nOffset.prototype.offsetLines = function(dist) {\n  if (dist < 0) throw new Error('Cannot apply negative margin to the line');\n  var union;\n  this.distance(dist);\n  if (isArray(this.vertices[0]) && typeof this.vertices[0][0] !== 'number') {\n    for (var i = 0, len = this._edges.length; i < len; i++) {\n      union = (i === 0) ?\n        this.offsetContour(this.vertices[i], this._edges[i]):\n        martinez.union(union, this.offsetContour(this.vertices[i], this._edges[i]));\n    }\n  } else {\n    union = (this.vertices.length === 1) ?\n      this.offsetPoint() :\n      this.offsetContour(this.vertices, this._edges);\n  }\n\n  return union;\n};\n\n\n/**\n * @param  {Array.<Array.<Number>>|Array.<Array.<...>>} curve\n * @param  {Array.<Edge>|Array.<Array.<...>>} edges\n * @return {Polygon}\n */\nOffset.prototype.offsetContour = function(curve, edges) {\n  var union, i, len;\n  if (isArray(curve[0]) && typeof curve[0][0] === 'number') {\n    // we have 1 less edge than vertices\n    for (i = 0, len = curve.length - 1; i < len; i++) {\n      var segment = this.ensureLastPoint(\n        this._offsetSegment(curve[i], curve[i + 1], edges[i], this._distance)\n      );\n      union = (i === 0) ?\n                [this.ensureLastPoint(segment)] :\n                martinez.union(union, this.ensureLastPoint(segment));\n    }\n  } else {\n    for (i = 0, len = edges.length; i < len; i++) {\n      union = (i === 0) ?\n        this.offsetContour(curve[i], edges[i]) :\n        martinez.union(union, this.offsetContour(curve[i], edges[i]));\n    }\n  }\n  return union;\n};\n\n\n/**\n * @param  {Number} distance\n * @return {Array.<Array.<Number>}\n */\nOffset.prototype.offsetPoint = function(distance) {\n  this.distance(distance);\n  var vertices = this._arcSegments * 2;\n  var points   = [];\n  var center   = this.vertices;\n  var radius   = this._distance;\n  var angle    = 0;\n\n  if (vertices % 2 === 0) vertices++;\n\n  for (var i = 0; i < vertices; i++) {\n    angle += (2 * Math.PI / vertices); // counter-clockwise\n    points.push([\n      center[0] + (radius * Math.cos(angle)),\n      center[1] + (radius * Math.sin(angle))\n    ]);\n  }\n\n  return orientRings([this.ensureLastPoint(points)]);\n};\n\n\nOffset.orientRings = orientRings;\n\nmodule.exports = Offset;\n"],
  "mappings": "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",
  "names": ["ret", "s", "event"]
}
